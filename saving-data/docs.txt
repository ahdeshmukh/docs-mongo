Rules for saving data
1) A document must have _id. if you save one without _id, mongo will assign one for you.
2) Size of document is limited to 16MB. If you want to store more, split it in multiple docs.

"show collections" shows a list of all collections. If you save a single collection, mongodb creates one more collection called as system.indexes. This collection stores the information of the _id field described in Rule 1 above which is used for indexing the data.

Saving data
Mongo can have _id  which is numeric, float, string or a complex object with multiple fields in it. All the examples below are valid for data types for _id. The only data type excluded for _id is an array.
db.foo.save({_id: 1 })
db.foo.save({  _id: 3.14 })
db.foo.save({ _id: "Hello" })
db.foo.save({ _id: ISODate() })
db.foo.save({ _id: {a: 'x', b:2 } })

If you try to save two different records with same id, mongo will overwrite the first record with the second one.
eg: run the below two commands. notice they have the same _id
	db.foo.save({_id: 1, name: 'Bob'})
	db.foo.save({_id: 1, name: 'Tom'})
when you do db.foo.find(), we will only find the record for Tom


TO avoid the problem mentioned above, use insert command instead of save
eg: running below commands will throw error for duplicate _id
	db.foo.insert({_id: 1, name: 'Bob'})
	db.foo.insert({_id: 1, name: 'Tom'})

if you do not specify _id while running insert command, mongo will generate an _id, but it would cause duplication of data
eg: running
	db.foo.insert({name: 'Bob'})
	db.foo.insert({name: 'Bob'})
will generate two records with name: 'Bob', but different _id fields generated by mongo

If an _id is not provided, mongo creates a unique _id and assigns it to the document. This _id also contains a timestamp which you can get to, using
ObjectId().getTimestamp()
Letting mongo create an _id is good for faster writes but slows down the reads.
If you want faster reads, your application should create a unique _id and pass it to mongo for saving. ( i assume preferable auto increment integer ).


Save Danger
eg: 
db.a.save({_id: 1, x: 10});
var doc = db.a.findOne({_id: 1});
doc.x = doc.x  + 1; //now value of x = 11
db.a.save(doc); // we are trying to make x increment by 1. but if someone has updated the value of x in the meantime, we have received a stale value of x, so the final data in the DB will be incorrect

Also while we are incrementing someone maybe altering the same document
eg: we have {_id: 1, x: 10} in collection a
we read the value and try to increment it by 1, so we expect final data to be {_id: 1, x: 11}
in the meantime if someone has added more data to the document {_id: 1, x: 11, y: 5}
now when we do the save operation, the data will look like {_id: 1, x: 11}. but it should have been {_id: 1, x: 12, y: 5}
x should be 12, because the latest value of x in the collection was 11, but since we had a stale value the data is wrong. also we should note that we have deleted y: 5 from the document.

Update command to the rescue

Mongo update command
db.foo.update(query, update, options);
foo => name of collection
query => which document you want to update ( same as id in sql db, so you do not update all the records )
update => change that you want to make to the document
options => one, many, upsert (one => just update first matching documents, many => update all matching documents, upsert => if document is not found, insert a new document). options parameter is not compulsory. default is one and !upsert

If in the above example, we want to increment the value of x by 1, we should use the update command
db.a.save({_id:1, x:10});
db.a.update({_id: 1}, {$inc:{x:1}});
$inc is MongoDB increment operator.
Even if two users try to concurrently increment the value of x, the update and $inc operator will make sure it will store the correct value in the db

If a client wants to add a field while someone is trying to increment an existing field in the document we should use $set and $inc
eg: if a document is ({_id: 1, x: 10}), and 
one client wants to add a field y, we should do
db.a.update({_id: 1}, {$set: {y:5}});
while other client wants to increment x, we should do
db.a.update({_id: 1}, {$inc:{x:1}});
Then final value of the document will be ({_id: 1, x: 11, y: 5}); which is what is expected

Unset command
if from the above example, we want to remove y: 5, we should use unset command as follows
db.a.update({_id:1}, {$unset:{y:VAL}}) or db.a.update({_id:1}, {$unset:{y:VAL}})
where VAL is an arbitrary value like '' or 0. it is just a placeholder

