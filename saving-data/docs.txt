Rules for saving data
1) A document must have _id. if you save one without _id, mongo will assign one for you.
2) Size of document is limited to 16MB. If you want to store more, split it in multiple docs.

"show collections" shows a list of all collections. If you save a single collection, mongodb creates one more collection called as system.indexes. This collection stores the information of the _id field described in Rule 1 above which is used for indexing the data.

Saving data
Mongo can have _id  which is numeric, float, string or a complex object with multiple fields in it. All the examples below are valid for data types for _id. The only data type excluded for _id is an array.
db.foo.save({_id: 1 })
db.foo.save({  _id: 3.14 })
db.foo.save({ _id: "Hello" })
db.foo.save({ _id: ISODate() })
db.foo.save({ _id: {a: 'x', b:2 } })

If you try to save two different records with same id, mongo will overwrite the first record with the second one.
eg: run the below two commands. notice they have the same _id
	db.foo.save({_id: 1, name: 'Bob'})
	db.foo.save({_id: 1, name: 'Tom'})
when you do db.foo.find(), we will only find the record for Tom


TO avoid the problem mentioned above, use insert command instead of save
eg: running below commands will throw error for duplicate _id
	db.foo.insert({_id: 1, name: 'Bob'})
	db.foo.insert({_id: 1, name: 'Tom'})

if you do not specify _id while running insert command, mongo will generate an _id, but it would cause duplication of data
eg: running
	db.foo.insert({name: 'Bob'})
	db.foo.insert({name: 'Bob'})
will generate two records with name: 'Bob', but different _id fields generated by mongo

If an _id is not provided, mongo creates a unique _id and assigns it to the document. This _id also contains a timestamp which you can get to, using
ObjectId().getTimestamp()
Letting mongo create an _id is good for faster writes but slows down the reads.
If you want faster reads, your application should create a unique _id and pass it to mongo for saving. ( i assume preferable auto increment integer ).


Save Danger
eg: 
db.a.save({_id: 1, x: 10});
var doc = db.a.findOne({_id: 1});
doc.x = doc.x  + 1; //now value of x = 11
db.a.save(doc); // we are trying to make x increment by 1. but if someone has updated the value of x in the meantime, we have received a stale value of x, so the final data in the DB will be incorrect

Also while we are incrementing someone maybe altering the same document
eg: we have {_id: 1, x: 10} in collection a
we read the value and try to increment it by 1, so we expect final data to be {_id: 1, x: 11}
in the meantime if someone has added more data to the document {_id: 1, x: 11, y: 5}
now when we do the save operation, the data will look like {_id: 1, x: 11}. but it should have been {_id: 1, x: 12, y: 5}
x should be 12, because the latest value of x in the collection was 11, but since we had a stale value the data is wrong. also we should note that we have deleted y: 5 from the document.

Update command to the rescue

Mongo update command
db.foo.update(query, update, options);
foo => name of collection
query => which document you want to update ( same as id in sql db, so you do not update all the records )
update => change that you want to make to the document
options => one, many, upsert (one => just update first matching documents, many => update all matching documents, upsert => if document is not found, insert a new document). options parameter is not compulsory. default is one and !upsert

If in the above example, we want to increment the value of x by 1, we should use the update command
db.a.save({_id:1, x:10});
db.a.update({_id: 1}, {$inc:{x:1}});
$inc is MongoDB increment operator.
Even if two users try to concurrently increment the value of x, the update and $inc operator will make sure it will store the correct value in the db

If a client wants to add a field while someone is trying to increment an existing field in the document we should use $set and $inc
eg: if a document is ({_id: 1, x: 10}), and 
one client wants to add a field y, we should do
db.a.update({_id: 1}, {$set: {y:5}});
while other client wants to increment x, we should do
db.a.update({_id: 1}, {$inc:{x:1}});
Then final value of the document will be ({_id: 1, x: 11, y: 5}); which is what is expected

Unset command
if from the above example, we want to remove y: 5, we should use unset command as follows
db.a.update({_id:1}, {$unset:{y:VAL}})
where VAL is an arbitrary value like '' or 0. it is just a placeholder

Rename operator

where id = any valid integer > 0

db.a.save({_id: id, Naem: 'Bob'}); // notice we are using Naem instead of Name
using the rename opertor we can fix it by doing
db.a.update({_id: id}, {$rename: {'Naem': 'Name'}});

Array operations
Push operator
db.foo.insert({_id: id});
db.foo.update({_id: id}, {$push: {things: 'one'}}); // should look like {_id: id, things: ['one']}
push some more items by doing 
db.foo.update({_id: id}, {$push: {things: 'two'}}); 
db.foo.update({_id: id}, {$push: {things: 'three'}});
// if you do db.foo.update({_id: id}, {$push: {things: 'three'}}); again, foo has element 'three' twice inside the things array

To prevent duplication of data as mentioned above, we can use $addToSet operator. this operator checks if an element exists in the set, and if not, then only adds it
eg: db.foo.update({_id: id}, {$addToSet: {things: 'four'}});
now if you do db.foo.update({_id: id}, {$addToSet: {things: 'four'}}); it will not add four again to the things array

Pull operator
To remove elements from an array
eg: db.foo.update({_id: id}, {$pull: {things: 'three'}}); // will remove three from the things array

Pop operator
if you want to remove last element from an array, do db.foo.update({_id: id}, {$pop: {things: 1}});
if you want to remove first element from an array, do db.foo.update({_id: id}, {$pop: {things: -1}});

** pull, push, pop and addToSet operators are only allowed on arrays, otherwise mongoDB throws an error

Multi Update
Let's say we have multiple documents in the DB and if we want to apply update to several documents and push another element on them
eg: db.foo.find() returns
{"_id": 1, "things": [1,2,3]}
{"_id": 2, "things": [2,3]}
{"_id": 3, "things": [3]}

if we want to push 4 to the things array in all the documents, we should do
db.foo.update({}, {$addToSet: {things: 4}}, {multi: true});

if we only want to update those documents who have value 2 in the things array, we can give the following command
db.foo.update({things: 2}, {$addToSet: {things: 5}}, {multi: true});
 
